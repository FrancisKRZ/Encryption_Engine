SPI CONTROLLER <ITER 1>

______________________________________________________________________________________________________________________________

`timescale 1ns / 1ps


/*
    clk         System Clock
    rst         Reset Signal
    
    data_in     Data In
    start       Start Signal
    miso        Master In-Slave Out
    
    data_out    Data Received via MISO
    done        SPI Transaction Done
    mosi        Master Out-Slave In
    spi_clk     SPI Clock Signal for Sync
    cs          SPI Chip Select


    Finite State Machine Design:
        IDLE:       Waiting for i_start signal
        SEND:       Shifts outs bits from o_spi_mosi whilst toggling o_spi_clk
        RECEIVE:    Capture data on i_spi_miso during correct clock phase <perhaps use Hamming codes(?)>
        DONE:       Assert done status and wait for reset or next transaction signal


    Since the SPI runs slower than the system clock, we've a Fast Domain to Slow Domain situation,
    as we've seen in the book -- we can remediate by making the source domain's signal longer to synchronize
    with the slower domain's <we'll achieve it by dividing our i_clk by a counter to generate o_spi_clk>


    In order to parallelize our data from serial, we'll utilize a shift register as seen in the book.
        8-bit shift register for transmitting i_data_in on o_spi_mosi
        8-bit shift register for collecting data from i_spi_miso for o_data_out


    Control Signals will be managed by o_spi_cs to assert a low signal at the start of a transaction
    then deassert a high signal after o_done

*/

module SPIController#(parameter 
    DATA_WIDTH = 8)
    (
    input i_clk,    
    input i_rst,
    input  [DATA_WIDTH-1:0] i_data_in,
    input i_start,
    output reg [DATA_WIDTH-1:0] o_data_out,
    output reg o_done,
    output reg o_spi_mosi,
    input i_spi_miso,
    output reg o_spi_clk,
    output reg o_spi_cs
    );


    // Parameters
    localparam IDLE = 2'b00, SEND = 2'b01, RECEIVE = 2'b10, DONE = 2'b11;

    // Registers
    reg [1:0] state = IDLE;
    reg [2:0] bit_counter = 0;
    reg [7:0] shift_register = 0;
    reg clk_div = 0;

    // Clock Divider (divide i_clk for SPI clock)
    always @(posedge i_clk or posedge i_rst) begin

        if (i_rst)
            clk_div <= 0;
        else
            clk_div <= ~clk_div;

    end

    always @(posedge clk_div or posedge i_rst) begin

        if (i_rst) begin
            state <= IDLE;
            o_spi_cs <= 1; // CS inactive
            o_done <= 0;
            bit_counter <= 0;
            shift_register <= 0;
            o_spi_clk <= 0;
            o_spi_mosi <= 0;

        end else begin

            case (state)

                IDLE: begin
                    o_done <= 0;
                    o_spi_cs <= 1; // CS inactive
                    if (i_start) begin
                        o_spi_cs <= 0; // Activate CS
                        state <= SEND;
                        shift_register <= i_data_in;
                        bit_counter <= 0;
                    end
                end

                SEND: begin

                    o_spi_clk <= ~o_spi_clk; // Toggle clock
                    if (!o_spi_clk) begin
                        o_spi_mosi <= shift_register[7]; // Send MSB
                        shift_register <= {shift_register[6:0], 1'b0}; // Shift left
                        bit_counter <= bit_counter + 1;
                        if (bit_counter == 7) state <= RECEIVE;
                    end
                end

                RECEIVE: begin

                    if (!o_spi_clk) begin
                        o_data_out <= {o_data_out[6:0], i_spi_miso}; // Shift in MISO
                        if (bit_counter == 7) state <= DONE;
                    end
                end

                DONE: begin

                    o_done <= 1;
                    o_spi_cs <= 1; // Deactivate CS
                    state <= IDLE;
                end
                
            endcase

        end // eof else
    end // eof always block



endmodule


______________________________________________________________________________________________________________________________


`timescale 1ns / 1ps

// A First-In First-Out RAM implementation, based on Getting Started with FPGAs provided examples
// Infers a Dual Port RAM (DPRAM) Based FIFO using a single clock
// Uses a Dual Port RAM but automatically handles read/write addresses.
// Parameters: 
// WIDTH     - Width of the FIFO
// DEPTH     - Max number of items able to be stored in the FIFO
//
// This FIFO cannot be used to cross clock domains, because in order to keep count
// correctly it would need to handle all metastability issues. 
// If crossing clock domains is required, use FIFO primitives directly from the vendor.


module FIFO_RAM #(
    parameter WIDTH = 8, 
    parameter DEPTH = 256
    )(
    input i_clk,
    input i_rst,
    input  [WIDTH-1:0] i_wr_data,
    input i_wr_en,
    input i_rd_en,
    output reg [WIDTH-1:0] o_rd_data,  // o_rd_data is now a reg
    output o_empty,
    output o_full
    );

    // The internal memory for the FIFO dual-port RAM
    reg [WIDTH-1:0] ram [DEPTH-1:0];

    // Read / Write pointers
    reg [$clog2(DEPTH)-1:0] r_wr_ptr;
    reg [$clog2(DEPTH)-1:0] r_rd_ptr;

    // Counter to track the number of elements in the FIFO
    reg [$clog2(DEPTH):0] r_count;

    // Write logic
    always @(posedge i_clk or negedge i_rst) begin

        if (!i_rst) begin
            r_wr_ptr <= 0;
        
        end else if (i_wr_en && !o_full) begin

            ram[r_wr_ptr] <= i_wr_data;
            r_wr_ptr <= r_wr_ptr + 1;
        
        end
    end

    // Read logic
    always @(posedge i_clk or negedge i_rst) begin

        if (!i_rst) begin
        
            r_rd_ptr <= 0;
            o_rd_data <= 0;  // Directly update o_rd_data here

        end else if (i_rd_en && !o_empty) begin
        
            o_rd_data <= ram[r_rd_ptr];  // Read from RAM and assign to o_rd_data
            r_rd_ptr <= r_rd_ptr + 1;
        
        end
    end

    // Counter logic
    always @(posedge i_clk or negedge i_rst) begin

        if (!i_rst) begin
        
            r_count <= 0;
        
        end else begin
            // If Writing and not Full
            if (i_wr_en && !o_full) begin
                r_count <= r_count + 1;
            end
            // If Reading and not Empty
            if (i_rd_en && !o_empty) begin
                r_count <= r_count - 1;
            end
        
        end
    end

    // Full and empty flags
    assign o_full  = r_count == DEPTH;
    assign o_empty = r_count == 0;

endmodule


______________________________________________________________________________________________________________________________


module EncryptionEngineTop #(
    parameter KEY_SIZE = 128, 
    parameter DATA_WIDTH = 8
    )(
    input i_clk,             // System clock
    input i_rst,             // Reset signal
    input i_spi_miso,        // SPI MISO (Master In Slave Out)
    output o_spi_mosi,       // SPI MOSI (Master Out Slave In)
    output o_spi_clk,        // SPI Clock
    output o_spi_cs,         // SPI Chip Select
    output o_w5500_rst,      // Reset for W5500
    input i_w5500_int,       // Interrupt from W5500
    input [KEY_SIZE-1:0] i_key,     // 128-bit encryption key
    output [DATA_WIDTH-1:0] o_encrypted_data,  // Output encrypted data
    input i_start,           // Start signal for encryption
    output o_done            // Done signal indicating encryption completion
    );

    // FIFO IP instance
    // 8-bit width 256-bit depth 
    // FIFO_wrapper fifo_inst (
    //     .almost_empty_0(),      // Optional, may be used during Encryption Throttle
    //     .almost_full_0(),       // Optional, may be used during Encryption Throttle
    //     .din_0(din_0),          // Data input to FIFO
    //     .dout_0(dout_0),        // Data output from FIFO
    //     .empty_0(empty_0),      // FIFO empty flag
    //     .full_0(full_0),        // FIFO full flag
    //     .rd_en_0(rd_en_0),      // Read enable signal for FIFO
    //     .reset(i_rst),          // Reset signal for FIFO
    //     .sys_clock(i_clk),      // Clock signal for FIFO
    //     .wr_en_0(wr_en_0)       // Write enable signal for FIFO
    // );


    FIFO_RAM #(
        .WIDTH(8),
        .DEPTH(256)
    ) fifo_inst (
        .i_clk(i_clk),
        .i_rst(i_rst),        // Note: May need to invert if reset polarity differs
        .i_wr_data(data_to_encrypt),  // Connect to pre-encryption data
        .i_wr_en(fifo_wr_en),
        .i_rd_en(fifo_rd_en),
        .o_rd_data(encrypted_data),   // Can be connected to o_encrypted_data
        .o_empty(fifo_empty),
        .o_full(fifo_full),
        .o_count(fifo_count)
    );
    // Additional encryption logic can be added here
    // Logic to interface with W5500, SPI, and encryption engine can be implemented

endmodule

______________________________________________________________________________________________________________________________



module W5500Driver(
    input i_clk,
    input i_rst,
    input i_spi_miso,
    output o_spi_mosi,
    output o_spi_clk,
    output o_spi_cs,
    output o_w5500_rst,
    input i_w5500_int,
    output [7:0] o_rx_data,
    output o_rx_valid,
    input [7:0] i_tx_data,
    input i_tx_valid,
    output o_tx_done
    );
endmodule

______________________________________________________________________________________________________________________________
