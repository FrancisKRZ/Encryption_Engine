SPI CONTROLLER <ITER 1>

______________________________________________________________________________________________________________________________

`timescale 1ns / 1ps


/*
    clk         System Clock
    rst         Reset Signal
    
    data_in     Data In
    start       Start Signal
    miso        Master In-Slave Out
    
    data_out    Data Received via MISO
    done        SPI Transaction Done
    mosi        Master Out-Slave In
    spi_clk     SPI Clock Signal for Sync
    cs          SPI Chip Select


    Finite State Machine Design:
        IDLE:       Waiting for i_start signal
        SEND:       Shifts outs bits from o_spi_mosi whilst toggling o_spi_clk
        RECEIVE:    Capture data on i_spi_miso during correct clock phase <perhaps use Hamming codes(?)>
        DONE:       Assert done status and wait for reset or next transaction signal


    Since the SPI runs slower than the system clock, we've a Fast Domain to Slow Domain situation,
    as we've seen in the book -- we can remediate by making the source domain's signal longer to synchronize
    with the slower domain's <we'll achieve it by dividing our i_clk by a counter to generate o_spi_clk>


    In order to parallelize our data from serial, we'll utilize a shift register as seen in the book.
        8-bit shift register for transmitting i_data_in on o_spi_mosi
        8-bit shift register for collecting data from i_spi_miso for o_data_out


    Control Signals will be managed by o_spi_cs to assert a low signal at the start of a transaction
    then deassert a high signal after o_done

*/

module SPIController#(parameter 
    DATA_WIDTH = 8)
    (
    input i_clk,    
    input i_rst,
    input  [DATA_WIDTH-1:0] i_data_in,
    input i_start,
    output reg [DATA_WIDTH-1:0] o_data_out,
    output reg o_done,
    output reg o_spi_mosi,
    input i_spi_miso,
    output reg o_spi_clk,
    output reg o_spi_cs
    );


    // Parameters
    localparam IDLE = 2'b00, SEND = 2'b01, RECEIVE = 2'b10, DONE = 2'b11;

    // Registers
    reg [1:0] state = IDLE;
    reg [2:0] bit_counter = 0;
    reg [7:0] shift_register = 0;
    reg clk_div = 0;

    // Clock Divider (divide i_clk for SPI clock)
    always @(posedge i_clk or posedge i_rst) begin

        if (i_rst)
            clk_div <= 0;
        else
            clk_div <= ~clk_div;

    end

    always @(posedge clk_div or posedge i_rst) begin

        if (i_rst) begin
            state <= IDLE;
            o_spi_cs <= 1; // CS inactive
            o_done <= 0;
            bit_counter <= 0;
            shift_register <= 0;
            o_spi_clk <= 0;
            o_spi_mosi <= 0;

        end else begin

            case (state)

                IDLE: begin
                    o_done <= 0;
                    o_spi_cs <= 1; // CS inactive
                    if (i_start) begin
                        o_spi_cs <= 0; // Activate CS
                        state <= SEND;
                        shift_register <= i_data_in;
                        bit_counter <= 0;
                    end
                end

                SEND: begin

                    o_spi_clk <= ~o_spi_clk; // Toggle clock
                    if (!o_spi_clk) begin
                        o_spi_mosi <= shift_register[7]; // Send MSB
                        shift_register <= {shift_register[6:0], 1'b0}; // Shift left
                        bit_counter <= bit_counter + 1;
                        if (bit_counter == 7) state <= RECEIVE;
                    end
                end

                RECEIVE: begin

                    if (!o_spi_clk) begin
                        o_data_out <= {o_data_out[6:0], i_spi_miso}; // Shift in MISO
                        if (bit_counter == 7) state <= DONE;
                    end
                end

                DONE: begin

                    o_done <= 1;
                    o_spi_cs <= 1; // Deactivate CS
                    state <= IDLE;
                end
                
            endcase

        end // eof else
    end // eof always block



endmodule


______________________________________________________________________________________________________________________________
