SPI CONTROLLER <ITER 1>

______________________________________________________________________________________________________________________________

`timescale 1ns / 1ps


/*
    clk         System Clock
    rst         Reset Signal
    
    data_in     Data In
    start       Start Signal
    miso        Master In-Slave Out
    
    data_out    Data Received via MISO
    done        SPI Transaction Done
    mosi        Master Out-Slave In
    spi_clk     SPI Clock Signal for Sync
    cs          SPI Chip Select


    Finite State Machine Design:
        IDLE:       Waiting for i_start signal
        SEND:       Shifts outs bits from o_spi_mosi whilst toggling o_spi_clk
        RECEIVE:    Capture data on i_spi_miso during correct clock phase <perhaps use Hamming codes(?)>
        DONE:       Assert done status and wait for reset or next transaction signal


    Since the SPI runs slower than the system clock, we've a Fast Domain to Slow Domain situation,
    as we've seen in the book -- we can remediate by making the source domain's signal longer to synchronize
    with the slower domain's <we'll achieve it by dividing our i_clk by a counter to generate o_spi_clk>


    In order to parallelize our data from serial, we'll utilize a shift register as seen in the book.
        8-bit shift register for transmitting i_data_in on o_spi_mosi
        8-bit shift register for collecting data from i_spi_miso for o_data_out


    Control Signals will be managed by o_spi_cs to assert a low signal at the start of a transaction
    then deassert a high signal after o_done

*/

module SPIController#(parameter 
    DATA_WIDTH = 8)
    (
    input i_clk,    
    input i_rst,
    input  [DATA_WIDTH-1:0] i_data_in,
    input i_start,
    output reg [DATA_WIDTH-1:0] o_data_out,
    output reg o_done,
    output reg o_spi_mosi,
    input i_spi_miso,
    output reg o_spi_clk,
    output reg o_spi_cs
    );


    // Parameters
    localparam IDLE = 2'b00, SEND = 2'b01, RECEIVE = 2'b10, DONE = 2'b11;

    // Registers
    reg [1:0] state = IDLE;
    reg [2:0] bit_counter = 0;
    reg [7:0] shift_register = 0;
    reg clk_div = 0;

    // Clock Divider (divide i_clk for SPI clock)
    always @(posedge i_clk or posedge i_rst) begin

        if (i_rst)
            clk_div <= 0;
        else
            clk_div <= ~clk_div;

    end

    always @(posedge clk_div or posedge i_rst) begin

        if (i_rst) begin
            state <= IDLE;
            o_spi_cs <= 1; // CS inactive
            o_done <= 0;
            bit_counter <= 0;
            shift_register <= 0;
            o_spi_clk <= 0;
            o_spi_mosi <= 0;

        end else begin

            case (state)

                IDLE: begin
                    o_done <= 0;
                    o_spi_cs <= 1; // CS inactive
                    if (i_start) begin
                        o_spi_cs <= 0; // Activate CS
                        state <= SEND;
                        shift_register <= i_data_in;
                        bit_counter <= 0;
                    end
                end

                SEND: begin

                    o_spi_clk <= ~o_spi_clk; // Toggle clock
                    if (!o_spi_clk) begin
                        o_spi_mosi <= shift_register[7]; // Send MSB
                        shift_register <= {shift_register[6:0], 1'b0}; // Shift left
                        bit_counter <= bit_counter + 1;
                        if (bit_counter == 7) state <= RECEIVE;
                    end
                end

                RECEIVE: begin

                    if (!o_spi_clk) begin
                        o_data_out <= {o_data_out[6:0], i_spi_miso}; // Shift in MISO
                        if (bit_counter == 7) state <= DONE;
                    end
                end

                DONE: begin

                    o_done <= 1;
                    o_spi_cs <= 1; // Deactivate CS
                    state <= IDLE;
                end
                
            endcase

        end // eof else
    end // eof always block



endmodule


______________________________________________________________________________________________________________________________


`timescale 1ns / 1ps

// A First-In First-Out RAM implementation, based on Getting Started with FPGAs provided examples
// Infers a Dual Port RAM (DPRAM) Based FIFO using a single clock
// Uses a Dual Port RAM but automatically handles read/write addresses.
// Parameters: 
// WIDTH     - Width of the FIFO
// DEPTH     - Max number of items able to be stored in the FIFO
//
// This FIFO cannot be used to cross clock domains, because in order to keep count
// correctly it would need to handle all metastability issues. 
// If crossing clock domains is required, use FIFO primitives directly from the vendor.


module FIFO_RAM #(
    parameter WIDTH = 8, 
    parameter DEPTH = 256
    )(
    input i_clk,
    input i_rst,
    input  [WIDTH-1:0] i_wr_data,
    input i_wr_en,
    input i_rd_en,
    output reg [WIDTH-1:0] o_rd_data,  // o_rd_data is now a reg
    output o_empty,
    output o_full
    );

    // The internal memory for the FIFO dual-port RAM
    reg [WIDTH-1:0] ram [DEPTH-1:0];

    // Read / Write pointers
    reg [$clog2(DEPTH)-1:0] r_wr_ptr;
    reg [$clog2(DEPTH)-1:0] r_rd_ptr;

    // Counter to track the number of elements in the FIFO
    reg [$clog2(DEPTH):0] r_count;

    // Write logic
    always @(posedge i_clk or negedge i_rst) begin

        if (!i_rst) begin
            r_wr_ptr <= 0;
        
        end else if (i_wr_en && !o_full) begin

            ram[r_wr_ptr] <= i_wr_data;
            r_wr_ptr <= r_wr_ptr + 1;
        
        end
    end

    // Read logic
    always @(posedge i_clk or negedge i_rst) begin

        if (!i_rst) begin
        
            r_rd_ptr <= 0;
            o_rd_data <= 0;  // Directly update o_rd_data here

        end else if (i_rd_en && !o_empty) begin
        
            o_rd_data <= ram[r_rd_ptr];  // Read from RAM and assign to o_rd_data
            r_rd_ptr <= r_rd_ptr + 1;
        
        end
    end

    // Counter logic
    always @(posedge i_clk or negedge i_rst) begin

        if (!i_rst) begin
        
            r_count <= 0;
        
        end else begin
            // If Writing and not Full
            if (i_wr_en && !o_full) begin
                r_count <= r_count + 1;
            end
            // If Reading and not Empty
            if (i_rd_en && !o_empty) begin
                r_count <= r_count - 1;
            end
        
        end
    end

    // Full and empty flags
    assign o_full  = r_count == DEPTH;
    assign o_empty = r_count == 0;

endmodule


______________________________________________________________________________________________________________________________


module EncryptionEngineTop #(
    parameter KEY_SIZE = 128, 
    parameter DATA_WIDTH = 8
    )(
    input i_clk,             // System clock
    input i_rst,             // Reset signal
    input i_spi_miso,        // SPI MISO (Master In Slave Out)
    output o_spi_mosi,       // SPI MOSI (Master Out Slave In)
    output o_spi_clk,        // SPI Clock
    output o_spi_cs,         // SPI Chip Select
    output o_w5500_rst,      // Reset for W5500
    input i_w5500_int,       // Interrupt from W5500
    input [KEY_SIZE-1:0] i_key,     // 128-bit encryption key
    output [DATA_WIDTH-1:0] o_encrypted_data,  // Output encrypted data
    input i_start,           // Start signal for encryption
    output o_done            // Done signal indicating encryption completion
    );

    // FIFO IP instance
    // 8-bit width 256-bit depth 
    // FIFO_wrapper fifo_inst (
    //     .almost_empty_0(),      // Optional, may be used during Encryption Throttle
    //     .almost_full_0(),       // Optional, may be used during Encryption Throttle
    //     .din_0(din_0),          // Data input to FIFO
    //     .dout_0(dout_0),        // Data output from FIFO
    //     .empty_0(empty_0),      // FIFO empty flag
    //     .full_0(full_0),        // FIFO full flag
    //     .rd_en_0(rd_en_0),      // Read enable signal for FIFO
    //     .reset(i_rst),          // Reset signal for FIFO
    //     .sys_clock(i_clk),      // Clock signal for FIFO
    //     .wr_en_0(wr_en_0)       // Write enable signal for FIFO
    // );


    FIFO_RAM #(
        .WIDTH(8),
        .DEPTH(256)
    ) fifo_inst (
        .i_clk(i_clk),
        .i_rst(i_rst),        // Note: May need to invert if reset polarity differs
        .i_wr_data(data_to_encrypt),  // Connect to pre-encryption data
        .i_wr_en(fifo_wr_en),
        .i_rd_en(fifo_rd_en),
        .o_rd_data(encrypted_data),   // Can be connected to o_encrypted_data
        .o_empty(fifo_empty),
        .o_full(fifo_full),
        .o_count(fifo_count)
    );
    // Additional encryption logic can be added here
    // Logic to interface with W5500, SPI, and encryption engine can be implemented

endmodule

______________________________________________________________________________________________________________________________



module W5500Driver(
    input i_clk,
    input i_rst,
    input i_spi_miso,
    output o_spi_mosi,
    output o_spi_clk,
    output o_spi_cs,
    output o_w5500_rst,
    input i_w5500_int,
    output [7:0] o_rx_data,
    output o_rx_valid,
    input [7:0] i_tx_data,
    input i_tx_valid,
    output o_tx_done
    );
endmodule

______________________________________________________________________________________________________________________________


module W5500Driver #(
    parameter DATA_WIDTH = 8,          // Data width (in bits)
    parameter IP_ADDR = 32'hC0A80001,  // Default IP address (192.168.0.1)
    parameter GATEWAY_ADDR = 32'hC0A80001, // Gateway IP address
    parameter SUBNET_MASK = 32'hFFFFFF00, // Subnet mask (255.255.255.0)
    parameter PORT = 16'h1337          // Default port
)(
    input wire i_clk,                  // System clock
    input wire i_rst,                  // Reset signal
    input wire i_spi_miso,             // SPI MISO (from W5500)
    output wire o_spi_mosi,            // SPI MOSI (to W5500)
    output wire o_spi_clk,             // SPI Clock (SCLK)
    output wire o_spi_cs,              // SPI Chip Select (CS)
    output wire o_w5500_rst,           // W5500 Reset
    input wire i_w5500_int,            // W5500 Interrupt
    output wire o_busy,                // Indicate if W5500 is busy
    output reg o_data_ready,          // Data ready flag (indicates received data)
    output reg [DATA_WIDTH-1:0] o_data_out // Data output (received data)
);

    // Internal registers for communication
    reg [7:0] tx_buffer;            // Transmission buffer for SPI
    reg [7:0] rx_buffer;            // Receiver buffer for SPI
    reg [15:0] socket_buffer;       // Buffer to handle data between W5500 and FIFO
    reg [31:0] ip_addr;             // IP Address (set to default)
    reg [31:0] gateway_addr;        // Gateway IP Address
    reg [31:0] subnet_mask;         // Subnet mask

    // State machines state for initialization and data transfer
    localparam IDLE         = 4'b0000;
    localparam INIT         = 4'b0001;
    localparam SEND_DATA    = 4'b0010;
    localparam RECEIVE_DATA = 4'b0100;
    localparam WAIT_INT     = 4'b1000;

    reg [1:0] r_current_state, r_next_state;


    // SPI control signals
    reg [7:0] spi_data_in;
    reg spi_start, spi_done;
    
    // Initialize W5500 configuration (IP, subnet, gateway)
    task initialize_w5500;
        // Write default IP, gateway, subnet, and port to W5500 registers using SPI
        // These should map to specific registers in the W5500, e.g., W5500_Sn_CR, W5500_Sn_IR
        // You need to use SPI to send data to the W5500 to configure it.
    endtask

    // SPI Communication logic
    always @(posedge i_clk) begin
        if (i_rst) begin
            r_current_state <= IDLE;
        end else begin
            r_current_state <= r_next_state;
        end
    end

    always @(*) begin
        case (r_current_state)
            IDLE: begin
                // Reset the system or wait for initialization
                r_next_state = INIT;
            end
            INIT: begin
                // Initialize W5500
                r_next_state = SEND_DATA;
            end
            SEND_DATA: begin
                // Send data to W5500 for transmission over Ethernet
                r_next_state = WAIT_INT;
            end
            RECEIVE_DATA: begin
                // Retrieve data from W5500 into the FIFO
                r_next_state = WAIT_INT;
            end
            WAIT_INT: begin
                // Wait for an interrupt to signal incoming data or other events
                if (i_w5500_int) begin
                    r_next_state = RECEIVE_DATA;
                end else begin
                    r_next_state = SEND_DATA;
                end
            end
            default: begin
                r_next_state = IDLE;
            end
        endcase
    end

    // SPI data transfer logic (send/receive)
    always @(posedge i_clk) begin
        if (spi_done) begin
            // Handle SPI transmission completion and data receipt
            if (r_current_state == RECEIVE_DATA) begin
                o_data_out <= rx_buffer;  // Send received data to FIFO
                o_data_ready <= 1;        // Data is ready to be processed
            end
        end
    end

    // Reset the W5500
    assign o_w5500_rst = (r_current_state == INIT);

    // SPI Control Signals
    assign o_spi_mosi = spi_data_in;   // Output to MOSI
    assign o_spi_clk = i_clk;          // Clock signal for SPI
    assign o_spi_cs = (r_current_state != IDLE);  // Chip select (active when not in idle state)

    // Output busy signal when communication is ongoing
    assign o_busy = (r_current_state != IDLE);

endmodule
